# Medium

## 7주차 과제 체크포인트

### 기본과제

#### Medium

- [x] 총 11개의 파일, 115개의 단위 테스트를 무사히 작성하고 통과시킨다.

#### 질문

> Q. medium.useEventOperations.spec.tsx > 아래 toastFn과 mock과 이 fn은 무엇을 해줄까요?
```
const toastFn = vi.fn();

vi.mock('@chakra-ui/react', async () => {
  const actual = await vi.importActual('@chakra-ui/react');
  return {
    ...actual,
    useToast: () => toastFn,
  };
});
```
- `toastFn`은 Vitest의 mock 함수입니다. 실제로는 아무 동작도 하지 않고, 나중에 호출 여부나 인자 등을 확인할 수 있습니다.
- `@chakra-ui/react` 모듈을 부분적으로 mocking합니다. useToast 훅만 실제 구현 대신 () => toastFn으로 대체합니다.
- `toast()` 호출 여부와 인자를 테스트에서 쉽게 검증하기 위함입니다.

> Q. medium.integration.spec.tsx > 여기서 ChakraProvider로 묶어주는 동작은 의미있을까요? 있다면 어떤 의미일까요?
- `Chakra` 컴포넌트가 동작하려면 `ChakraProvider`의 컨텍스트가 필요합니다.
- 실제 앱과 동일한 환경을 테스트 코드에서도 구성하기 위해 감쌉니다.

> Q. handlersUtils > 아래 여러가지 use 함수는 어떤 역할을 할까요? 어떻게 사용될 수 있을까요?
- `MSW`를 사용하여 API 요청을 가짜로 처리합니다.
- 각 함수는 목적에 따라 이벤트 생성/수정/삭제를 가로채는 mock 핸들러를 등록합니다.
```
setupMockHandlerCreation() 호출 → "생성" 관련 mock 세팅
setupMockHandlerUpdating() 호출 → "수정" 관련 mock 세팅
setupMockHandlerDeletion() 호출 → "삭제" 관련 mock 세팅
```

> Q. setupTests.ts > 왜 이 시간을 설정해주는 걸까요?
- `new Date(), Date.now()` 같은 시간 관련 코드가 테스트마다 다르게 동작하지 않도록 시스템 시간을 고정합니다.
- `useFakeTimers()`와 함께 사용해 안정적이고 예측 가능한 테스트를 만듭니다.

### 심화 과제

- [x] App 컴포넌트 적절한 단위의 컴포넌트, 훅, 유틸 함수로 분리했는가?
- [x] 해당 모듈들에 대한 적절한 테스트를 5개 이상 작성했는가?

## 과제 셀프회고

<!-- 과제에 대한 회고를 작성해주세요 -->
1주간의 방학이 끝나고 오랜만에 다시 항해를 시작하면서, 그동안 다른 개발이나 공부를 해왔음에도 약간의 긴장감이 느슨해졌던 것 같다. 
이번 주차는 테스트 과제였고, 학교 수업 외에는 프론트엔드 코드에서 테스트를 직접 작성해본 경험이 거의 없어 다소 낯설게 느껴졌다.
처음 도전하는 테스트라 Medium 난이도를 선택했지만, 심화과제에서는 MSW 세팅부터 시작해 생각보다 손봐야 할 부분이 많아 오히려 Hard 난이도를 선택해볼 걸 하는 아쉬움도 남는다.
그럼에도 불구하고 세팅에 많은 시간을 들이지 않은 덕분에 테스트 로직 자체에 더 집중할 수 있었고, 다양한 테스트 시나리오를 깊이 고민해볼 수 있었다. 이번 과제를 통해 테스트의 필요성과 작성 흐름에 대해 체감할 수 있었고, 앞으로도 익숙해져야 할 중요한 영역이라는 걸 느꼈다.

### 기술적 성장

<!-- 예시
- 새로 학습한 개념
- 기존 지식의 재발견/심화
- 구현 과정에서의 기술적 도전과 해결
-->

- `MSW`를 활용한 API mocking을 처음으로 적용해보며 테스트 환경 구성에 대한 감을 익힐 수 있었다.
- 테스트 코드를 작성할 때 어떤 단위를 기준으로 나누고 검증할지에 대해 고민하게 되었고, 로직 중심 테스트와 UI 인터랙션 테스트의 구분에 대해 생각해볼 수 있었다.
- 통합 테스트를 진행하면서 mock 데이터를 생성하고 리스트에 반영하는 흐름이 자연스럽게 연결되었는지 판단하기 어려웠고, 실제로 테스트가 여러 번 실패하면서 디버깅에 시간을 많이 썼다.
하지만 그 과정에서 비동기 렌더링 타이밍, 상태 반영 시점 등을 파악하게 되면서 테스트에 대한 이해도가 확실히 높아졌다.
- 또한 `data-testid` 속성을 활용해 테스트에서 원하는 요소를 안정적으로 선택할 수 있다는 점도 이번에 처음 알게 되었고, 앞으로는 테스트까지 고려한 마크업 설계가 중요하다는 것을 느꼈다.


### 코드 품질

<!-- 예시
- 특히 만족스러운 구현
- 리팩토링이 필요한 부분
- 코드 설계 관련 고민과 결정
-->
- `Calendar` 컴포넌트는 Header와 View로 나누고, 내부적으로도 Week와 Month 뷰를 분리한 구조는 만족스럽지만, 두 뷰가 공통으로 사용하는 일부 UI 요소나 로직을 별도 컴포넌트로 분리했다면 더 깔끔했을 것 같다는 아쉬움이 남는다.
- `ScheduleForm`도 구조적으로는 잘 정리하려고 했지만, 입력 폼을 더 작은 단위로 분리하는 데에는 시간상 제약이 있었다. 예를 들어 각 입력 항목(제목, 시간, 위치 등)을 컴포넌트화할 수 있었을 것 같다.
- `ScheduleFormContainer`에서 수정 대상 이벤트(`editingEvent`)를 상위에서 props로 받아야 했기 때문에, 이를 어떻게 상태 관리할지 고민이 많았다.  
최종적으로는 상위에서 `editingEvent`와 `setEditingEvent`를 전달받고, 내부에서는 `useEffect`를 활용해 초기값을 설정했다.  
초기화 로직은 `editEvent`라는 커스텀 함수로 분리하고 `useCallback`으로 감싸 재사용할 수 있게 구성했는데, 이 방식이 구조적으로 적절했는지에 대해서는 아직 고민 중이다.
- `useEventForm`의 상태가 많아지다 보니, 내부 로직을 values, setters, errors, handlers, 그리고 그 외 유틸 함수들로 나눠서 관리했다. 구조적으로는 나쁘지 않아 보이지만, 이렇게 나누는 방식이 과연 맞는지 확신은 잘 들지 않았다.
특히 `resetForm`이나 `editEvent` 같은 함수는 `handlers`로 봐야 할지, 별도 유틸로 분리해야 할지 경계가 모호하게 느껴졌고, 전체적으로 관리 방식에 대해 더 나은 방향이 있을지 고민이 됐다.
```
return {
  values: { title, date, startTime, ... },
  setters: { setTitle, setDate, setStartTime, ... },
  errors: { startTimeError, endTimeError },
  handlers: { handleStartTimeChange, handleEndTimeChange },
  editEvent,
  resetForm,
};
```

### 학습 효과 분석

<!-- 예시
- 가장 큰 배움이 있었던 부분
- 추가 학습이 필요한 영역
- 실무 적용 가능성
-->

- 테스트 코드 작성에 대한 막연한 두려움이 많이 해소되었다. 처음에는 어렵게 느껴졌지만, 직접 작성해보며 흐름을 익힐 수 있었다.
특히 회사에서 테스트 코드를 적용하고 싶었지만, 솔루션의 특성에 따라 어떤 테스트가 적절한지 판단이 어려웠는데, 멘토링을 통해 어느 정도 기준을 잡을 수 있었다.
예를 들어, 단순한 검수 화면은 단위 테스트(Unit Test) 위주로 작성하고, 사용자의 흐름이 중요한 리스트나 폼 화면은 E2E나 비주얼 테스트가 더 적합하다는 점을 이해하게 되었다.
- 이전에는 렌더링 안정화를 위해 `waitFor`를 사용했지만, 비동기 로직이 없는 경우에는 `await act(() => null)`처럼 최소한의 act 호출만으로도 충분하다는 점을 멘토링을 통해 알게 되었고, 이를 코드에 반영해 개선했다.
```
await act(() => null);
expect(screen.queryByText('검색 결과가 없습니다')).not.toBeInTheDocument();
```
- 테스트 범위가 애매할 때는 커버리지 도구를 활용해 부족한 부분을 채워가면 된다는 점도 배울 수 있었다. 다만 코치님 화면에서는 커버리지가 시각적으로 잘 표시되던 반면, 내 환경에서는 extension을 설치했음에도 시각화가 제대로 되지 않아 확인이 어려웠다.
이번 발제 전까지는 커버리지 시각화 도구를 제대로 적용해서 테스트 보완에 활용해보고 싶다.


### 과제 피드백

<!-- 예시
- 과제에서 모호하거나 애매했던 부분
- 과제에서 좋았던 부분
-->
- 유틸 함수부터 커스텀 훅, 전체적인 통합 테스트까지 단계적으로 경험해볼 수 있어서 좋았습니다.
- 과제를 난이도별로 나눠주셔서, 각자 수준에 맞게 선택하고 도전할 수 있었던 점도 좋았습니다.

## 리뷰 받고 싶은 내용
- 코멘트에 질문이 하나 더 있습니다!
- 현재 회사에서 개발하는 페이지(다단계 입력 흐름 화면)에 테스트를 적용해보면 좋겠다는 생각이 들었습니다. 인터랙션이 많은 화면에서는 어떤 종류의 테스트(E2E, 통합, 단위 테스트 등)가 가장 효과적인가요? 그리고 자주 오류가 발생하는 화면에도 테스트가 유의미하게 동작 안정성을 높여줄 수 있을까요?
- 애매할 때는 커버리지를 100% 채워보라고 하셨는데, 테스트 코드를 먼저 상세히 작성해두고 이후 코드 수정 방향을 잡는 방식이 좋은 접근일까요?
또, 커버리지 도구를 효과적으로 활용하려면 어느 정도 테스트 코드가 작성된 상태여야 할 것 같은데, 커버리지는 보통 어느 시점에 확인하는 게 가장 적절할까요?
- 이력서를 최대한 길게 작성한 뒤 압축해서 1차 이력서를 완성할 예정이고, 추후엔 멘토링에서 추천해주셨던 트러블슈팅 문서도 작성할 계획입니다. 그런데 이력서에 첨부할 링크들—블로그, GitHub, LinkedIn 등—관리할 것들이 한꺼번에 너무 많아져서, 어떤 것부터 우선순위로 준비하면 좋을지 고민입니다.
갑자기 몰아서 하려니 부담이 커서, 평소에 꾸준히 준비하려고 하는데 어떤 순서나 기준으로 관리해나가면 좋을까요?
